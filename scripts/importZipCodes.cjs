#!/usr/bin/env node

/**
 * importZipCodes.cjs
 *
 * Imports data/us_zip_coordinates.json into the Firestore `zip_coordinates`
 * collection using batched writes. Each zip code becomes a document with the
 * zip as the document ID.
 *
 * Document structure:
 *   zip_coordinates/{zip} -> { lat, lng, city, state, source, imported_at }
 *
 * Usage:
 *   node scripts/importZipCodes.cjs
 *
 * Prerequisites:
 *   - firebase-admin installed in the project
 *   - Service account key at ./firebase-service-account.json
 *   - data/us_zip_coordinates.json generated by generateZipDatabase.cjs
 *
 * WARNING: This will write ~41,000 documents to Firestore. At $0.18/100K writes
 * on the Blaze plan, this costs approximately $0.07. However, batch writes
 * still count as individual write operations for billing purposes.
 */

const admin = require("firebase-admin");
const fs = require("fs");
const path = require("path");

// ── Configuration ────────────────────────────────────────────────────────────

const SERVICE_ACCOUNT_PATH = path.join(
  __dirname,
  "..",
  "firebase-service-account.json"
);
const DATA_FILE = path.join(__dirname, "..", "data", "us_zip_coordinates.json");
const COLLECTION = "zip_coordinates";
const BATCH_SIZE = 500; // Firestore batch limit
const SOURCE_TAG = "geonames_import"; // Tag for tracking data provenance

// ── Initialize Firebase ──────────────────────────────────────────────────────

if (!fs.existsSync(SERVICE_ACCOUNT_PATH)) {
  console.error(`Service account not found: ${SERVICE_ACCOUNT_PATH}`);
  console.error("Download from Firebase Console > Project Settings > Service Accounts");
  process.exit(1);
}

const serviceAccount = require(SERVICE_ACCOUNT_PATH);

admin.initializeApp({
  credential: admin.credential.cert(serviceAccount),
});

const db = admin.firestore();

// ── Main ─────────────────────────────────────────────────────────────────────

async function main() {
  // Load zip code data
  if (!fs.existsSync(DATA_FILE)) {
    console.error(`Data file not found: ${DATA_FILE}`);
    console.error("Run first: node scripts/generateZipDatabase.cjs");
    process.exit(1);
  }

  console.log(`Loading zip code data from ${DATA_FILE}...`);
  const zipData = JSON.parse(fs.readFileSync(DATA_FILE, "utf-8"));
  const entries = Object.entries(zipData);
  const totalZips = entries.length;

  console.log(`  Total zip codes to import: ${totalZips.toLocaleString()}`);
  console.log(`  Batch size: ${BATCH_SIZE}`);
  console.log(`  Total batches: ${Math.ceil(totalZips / BATCH_SIZE)}`);
  console.log(`  Collection: ${COLLECTION}`);
  console.log();

  let imported = 0;
  let batchCount = 0;
  const startTime = Date.now();

  for (let i = 0; i < entries.length; i += BATCH_SIZE) {
    const batch = db.batch();
    const chunk = entries.slice(i, i + BATCH_SIZE);
    batchCount++;

    for (const [zip, data] of chunk) {
      const ref = db.collection(COLLECTION).doc(zip);
      batch.set(
        ref,
        {
          lat: data.lat,
          lng: data.lng,
          city: data.city,
          state: data.state,
          source: SOURCE_TAG,
          imported_at: admin.firestore.FieldValue.serverTimestamp(),
        },
        { merge: true }
      );
    }

    await batch.commit();
    imported += chunk.length;

    // Progress tracking
    const elapsed = ((Date.now() - startTime) / 1000).toFixed(1);
    const pct = ((imported / totalZips) * 100).toFixed(1);
    const rate = (imported / ((Date.now() - startTime) / 1000)).toFixed(0);

    process.stdout.write(
      `\r  Batch ${batchCount}/${Math.ceil(totalZips / BATCH_SIZE)}: ` +
        `${imported.toLocaleString()}/${totalZips.toLocaleString()} ` +
        `(${pct}%) - ${elapsed}s elapsed - ${rate} zips/sec`
    );
  }

  const totalTime = ((Date.now() - startTime) / 1000).toFixed(1);
  console.log(`\n\nImport complete!`);
  console.log(`  Zip codes imported: ${imported.toLocaleString()}`);
  console.log(`  Batches committed: ${batchCount}`);
  console.log(`  Total time: ${totalTime}s`);
  console.log(`  Average rate: ${(imported / (totalTime)).toFixed(0)} zips/sec`);

  process.exit(0);
}

main().catch((err) => {
  console.error("\nImport failed:", err.message);
  process.exit(1);
});
